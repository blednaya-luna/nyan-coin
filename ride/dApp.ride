{-# STDLIB_VERSION 5 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

func getNumberByKey(key: String) = {
  match getInteger(this, key) {
    case number:Int => number
    case _ => 0
  }
}

let NONE = "none"
func getStringByKey(key: String) = {
  match getString(this, key) {
    case string:String => string
    case _ => NONE
  }
}

func getBooleanByKey(key: String) = {
  match getBoolean(this, key) {
    case boolean:Boolean => boolean
    case _ => false
  }
}

func isAdmin(caller: Address) = {
  this == caller
}

func getUserEmailKey(userAddress: String) = {
  "user_<" + userAddress + ">_email"
}
func getUserEmailValue(userAddress: String) = {
  getStringByKey(getUserEmailKey(userAddress))
}

func getResponsibleKey(userAddress: String) = {
  "user_<" + userAddress + ">_responsible"
}
func getResponsibleValue(userAddress: String) = {
  getBooleanByKey(getResponsibleKey(userAddress))
}

func getNyanTokenKey() = {
  "dApp_<" + toBase58String(this.bytes) +">_tokenId"
}
func getNyanTokenValue() = {
  getStringByKey(getNyanTokenKey())
}

func getAssetPriceKey(assetId: String) = {
  "asset_<" + assetId + ">_price"
}
func getAssetPriceValue(assetId: String) = {
  getNumberByKey(getAssetPriceKey(assetId))
}

func getAssetDataKey(assetId: String) = {
  "asset_<" + assetId + ">_data"
}
func getAssetDataValue(assetId: String) = {
  getStringByKey(getAssetPriceKey(assetId))
}

func getOrderDataKey(assetId: String, userAddress: String, transactionId: String) = {
  # TODO change key?
  "order_<" + assetId + "_" + userAddress + "_" + transactionId + ">_data" 
}
func getOrderDataValue(assetId: String, userAddress: String, transactionId: String) = {
  getStringByKey(getOrderDataKey(assetId, userAddress, transactionId))
}

@Callable(i)
func signUp(email: String) = {
  let userAddress = toBase58String(i.caller.bytes)
  let userEmail = getUserEmailValue(userAddress)

  if (userEmail != NONE) then {
    throw("User " + userEmail + " is already registered")
  } else {
    [
      StringEntry(getUserEmailKey(userAddress), email)
    ]
  }
}

@Callable(i)
func issueNyanToken(quantity: Int) = {
  let nyanToken = getNyanTokenValue()

  if (!isAdmin(i.caller)) then {
    throw("Function invoke not allowed, requested from non-admin address")
  } else if (nyanToken != NONE) then {
    throw("NYAN Token is already issued")
  } else {
    let nyanTokenIssue = Issue("NYAN Token", "NYAN Token is a cryptocurrency token that operates on the Waves platform", quantity, 0, true)
    let nyanTokenAssetId = nyanTokenIssue.calculateAssetId()
    [
      nyanTokenIssue,
      StringEntry(getNyanTokenKey(), toBase58String(nyanTokenAssetId))
    ]
  }
}

@Callable(i)
func reissueNyanToken(quantity: Int) = {
  let nyanToken = getNyanTokenValue()

  if (!isAdmin(i.caller)) then {
    throw("Function invoke not allowed, requested from non-admin address")
  } else if (nyanToken == NONE) then {
    throw("NYAN Token was not issued")
  } else {
    [
      Reissue(fromBase58String(nyanToken), quantity, true)
    ]
  }
}

@Callable(i)
func transferNyanToken(recipient: String, amount: Int) = {
  let userEmail = getUserEmailValue(recipient)
  let nyanTokenAssetId = fromBase58String(getNyanTokenValue())
  let currentDAppBalance = assetBalance(this, nyanTokenAssetId)
  let newDAppBalance = currentDAppBalance - amount

  if (!isAdmin(i.caller)) then {
    throw("Function invoke not allowed, requested from non-admin address")
  } else if (userEmail == NONE) then {
    throw("You cannot transfer NYAN Token to an unregistered user")
  } else if (amount < 0) then {
    throw("You cannot transfer a negative amount")
  } else if (newDAppBalance < 0) then {
    throw("Not enough NYAN Token to transfer")
  } else {
    [
      ScriptTransfer(Address(fromBase58String(recipient)), amount, nyanTokenAssetId)
    ]
  }
}

@Callable(i)
func issueAssetToken(name: String, description: String, quantity: Int, price: Int, data: String) = {
  let assetTokenIssue = Issue(name, description, quantity, 0, true)
  let assetTokenAssetId = assetTokenIssue.calculateAssetId()
  let assetToken = toBase58String(assetTokenAssetId)

  if (!isAdmin(i.caller)) then {
    throw("Function invoke not allowed, requested from non-admin address")
  } else if (quantity == 0) then {
    [
      assetTokenIssue,
      IntegerEntry(getAssetPriceKey(assetToken), price),
      StringEntry(getAssetDataKey(assetToken), data)
    ]
  } else {
    let nyanTokenAssetId = fromBase58String(getNyanTokenValue())
    let currentDAppBalance = assetBalance(this, nyanTokenAssetId)
    let amount = quantity * price
    let newDAppBalance = currentDAppBalance - amount

    if (newDAppBalance < 0) then {
      throw("Not enough NYAN Token to issue an asset")
    } else {
      [
        assetTokenIssue,
        Burn(nyanTokenAssetId, amount),
        IntegerEntry(getAssetPriceKey(assetToken), price),
        StringEntry(getAssetDataKey(assetToken), data)
      ]
    }
  }
}

@Callable(i)
func reissueAssetToken(assetId: String, quantity: Int) = {
  let nyanTokenAssetId = fromBase58String(getNyanTokenValue())
  let currentDAppBalance = assetBalance(this, nyanTokenAssetId)
  let price = getAssetPriceValue(assetId)
  let amount = quantity * price
  let newDAppBalance = currentDAppBalance - amount

  if (!isAdmin(i.caller)) then {
    throw("Function invoke not allowed, requested from non-admin address")
  } else if (newDAppBalance < 0) then {
    throw("Not enough NYAN Token to reissue an asset")
  } else {
    [
      Reissue(fromBase58String(assetId), quantity, true),
      Burn(nyanTokenAssetId, amount)
    ]
  }
}

@Callable(i)
func exchangeAssetToken(assetId: String, amount: Int) = {
  let payments = i.payments

  if (size(payments) == 0) then {
    throw("You need to attach the payment")
  } else {
    let paymentAmount = payments[0].amount
    let paymentAssetId = value(payments[0].assetId)
    let assetPrice = getAssetPriceValue(assetId)
    let assetAmount = amount * assetPrice
    let assetTokenAssetId = fromBase58String(assetId)


    if (paymentAmount < assetAmount) then {
      throw("Not enough NYAN Token to exchange an asset")
    } else if (paymentAmount == assetAmount) then {
      [
        ScriptTransfer(i.caller, amount, assetTokenAssetId),
        Burn(paymentAssetId, paymentAmount)
      ]
    } else {
      let paymentAmountChange = paymentAmount - assetAmount
      [
        ScriptTransfer(i.caller, amount, assetTokenAssetId),
        ScriptTransfer(i.caller, paymentAmountChange, paymentAssetId),
        Burn(paymentAssetId, assetAmount)
      ]
    }
  }
}

@Callable(i)
func setResponsibleStatus(userAddress: String) = {
  let isResponsible = getResponsibleValue(userAddress)

  if (!isAdmin(i.caller)) then {
    throw("Function invoke not allowed, requested from non-admin address")
  } else if (isResponsible) then {
    throw("User already have responsible status")
  } else {
    [
      BooleanEntry(getResponsibleKey(userAddress), true)
    ]
  }
}

@Callable(i)
func revokeResponsibleStatus(userAddress: String) = {
  let isResponsible = getResponsibleValue(userAddress)

  if (!isAdmin(i.caller)) then {
    throw("Function invoke not allowed, requested from non-admin address")
  } else if (!isResponsible) then {
    throw("User already don't have responsible status")
  } else {
    [
      BooleanEntry(getResponsibleKey(userAddress), false)
    ]
  }
}

# WIP
@Callable(i)
func requestReward() = {
  let payments = i.payments

  if (size(payments) == 0) then {
    throw("You need to attach the payment")
  } else {
    # TODO check that it is our token
    let paymentAssetId = value(payments[0].assetId)
    let paymentAmount = payments[0].amount
    let assetId = toBase58String(paymentAssetId)
    let userAddress = toBase58String(i.caller.bytes)
    let amount = toString(paymentAmount)
    let transactionId = toBase58String(i.transactionId)
    let orderData =
    "{" +
      "\"assetId\":\"" + assetId + "\"," +
      "\"amount\":\"" + amount + "\"," +
      "\"userAddress\":\"" + userAddress + "\"," +
      "\"transactionId\":\"" + transactionId + "\"," +
      "\"status\":\"" + "NEW" + "\"" +
    "}"

    [
      StringEntry(getOrderDataKey(assetId, userAddress, transactionId), orderData),
      Burn(paymentAssetId, paymentAmount)
    ]
  }
}

# @Verifier(tx)
# func verify() = sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey)

@Verifier(tx)
func verify() = {
  match tx {
      case _:InvokeScriptTransaction => sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey)
      case _ => tx.sender == this && sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey)
    }
}
